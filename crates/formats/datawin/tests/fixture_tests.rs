//! Fixture-based tests for the datawin parser.
//!
//! Each fixture is a small synthetic `data.win`-format file generated by
//! `src/bin/gen_fixtures.rs` and committed to `tests/fixtures/`. The fixtures
//! serve two purposes:
//!
//!   1. **Regression tests** for the Rust parser — assertions check exact
//!      field values, not just "no panic".
//!   2. **Reference inputs** for Kaitai Struct spec validation — load a `.bin`
//!      in the Kaitai Web IDE or via `ksc -t python` to verify that
//!      `game_maker_data.ksy` and `gml_bytecode.ksy` parse them correctly.
//!
//! See `src/bin/gen_fixtures.rs` for the kaitai validation workflow.

use datawin::bytecode::decode::{self, Operand};
use datawin::bytecode::opcode::Opcode;
use datawin::bytecode::types::DataType;
use datawin::chunks::code::Code;
use datawin::chunks::gen8::Gen8;
use datawin::reader::ChunkIndex;
use datawin::string_table::StringTable;
use datawin::version::BytecodeVersion;
use datawin::writer::{assemble_form, extract_chunks};

// ── Fixture bytes (compiled into the test binary via include_bytes!) ──────────

static MINIMAL: &[u8] = include_bytes!("fixtures/v15_minimal.bin");
static VARIETY: &[u8] = include_bytes!("fixtures/v15_bytecode_variety.bin");
static BREAK_SIGNALS: &[u8] = include_bytes!("fixtures/v15_break_signals.bin");

// ── v15_minimal ───────────────────────────────────────────────────────────────

/// FORM envelope: exactly 3 chunks in order GEN8, STRG, CODE.
#[test]
fn minimal_chunk_index() {
    let index = ChunkIndex::parse(MINIMAL).unwrap();
    assert_eq!(index.len(), 3);
    let magics: Vec<&str> = index.chunks().iter().map(|c| c.magic_str()).collect();
    assert_eq!(magics, ["GEN8", "STRG", "CODE"]);
}

/// GEN8: bytecode version 15, game_id 1, major 1, minor 0.
#[test]
fn minimal_gen8() {
    let index = ChunkIndex::parse(MINIMAL).unwrap();
    let entry = index.find(b"GEN8").unwrap();
    let gen8 =
        Gen8::parse(&MINIMAL[entry.data_offset()..entry.data_offset() + entry.size]).unwrap();

    assert_eq!(gen8.bytecode_version, BytecodeVersion(15));
    assert_eq!(gen8.game_id, 1);
    assert_eq!(gen8.major, 1);
    assert_eq!(gen8.minor, 0);
    assert!(!gen8.is_debug_disabled);
    assert!(gen8.room_order.is_empty());
    assert!(gen8.gms2_data.is_empty());
}

/// GEN8 StringRefs resolve correctly against the full file.
#[test]
fn minimal_gen8_string_refs() {
    let index = ChunkIndex::parse(MINIMAL).unwrap();
    let entry = index.find(b"GEN8").unwrap();
    let gen8 =
        Gen8::parse(&MINIMAL[entry.data_offset()..entry.data_offset() + entry.size]).unwrap();

    assert_eq!(gen8.filename.resolve(MINIMAL).unwrap(), "default");
    assert_eq!(gen8.config.resolve(MINIMAL).unwrap(), "default");
    assert_eq!(gen8.name.resolve(MINIMAL).unwrap(), "test_game");
    assert_eq!(gen8.display_name.resolve(MINIMAL).unwrap(), "test_game");
}

/// STRG: exactly 4 strings with correct content.
#[test]
fn minimal_strg() {
    let index = ChunkIndex::parse(MINIMAL).unwrap();
    let entry = index.find(b"STRG").unwrap();
    let strg_abs = entry.data_offset();
    let strg = StringTable::parse(
        &MINIMAL[strg_abs..strg_abs + entry.size],
        strg_abs,
    )
    .unwrap();

    assert_eq!(strg.len(), 4);
    assert_eq!(strg.get(0, MINIMAL).unwrap(), "");
    assert_eq!(strg.get(1, MINIMAL).unwrap(), "default");
    assert_eq!(strg.get(2, MINIMAL).unwrap(), "test_game");
    assert_eq!(strg.get(3, MINIMAL).unwrap(), "gml_Script_test");
}

/// CODE: 1 entry whose name resolves to "gml_Script_test".
#[test]
fn minimal_code_entry() {
    let index = ChunkIndex::parse(MINIMAL).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &MINIMAL[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    assert_eq!(code.entries.len(), 1);
    let e = &code.entries[0];
    assert_eq!(e.name.resolve(MINIMAL).unwrap(), "gml_Script_test");
    assert_eq!(e.locals_count, 0);
    assert_eq!(e.args_count, 0);
}

/// Bytecode: exactly `PushI Int16(42)` + `Ret`.
#[test]
fn minimal_bytecode_decode() {
    let index = ChunkIndex::parse(MINIMAL).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &MINIMAL[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    let bc = code.entry_bytecode(0, MINIMAL).unwrap();
    let instructions = decode::decode(bc).unwrap();

    assert_eq!(instructions.len(), 2);

    assert_eq!(instructions[0].opcode, Opcode::PushI);
    assert_eq!(instructions[0].type1, DataType::Int16);
    assert!(matches!(instructions[0].operand, Operand::Int16(42)));

    assert_eq!(instructions[1].opcode, Opcode::Ret);
    assert!(matches!(instructions[1].operand, Operand::None));
}

/// Bytecode round-trip: encode(decode(bc)) == bc.
#[test]
fn minimal_bytecode_round_trip() {
    let index = ChunkIndex::parse(MINIMAL).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &MINIMAL[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    let bc = code.entry_bytecode(0, MINIMAL).unwrap();
    let instructions = decode::decode(bc).unwrap();
    let reencoded = datawin::bytecode::encode::encode(&instructions);
    assert_eq!(bc, reencoded.as_slice());
}

/// File round-trip: extract all chunks → assemble → identical bytes.
#[test]
fn minimal_file_round_trip() {
    let index = ChunkIndex::parse(MINIMAL).unwrap();
    let chunks = extract_chunks(&index, MINIMAL);
    let reassembled = assemble_form(&chunks);
    assert_eq!(MINIMAL, reassembled.as_slice());
}

// ── v15_bytecode_variety ──────────────────────────────────────────────────────

/// All 10 instructions decode with correct opcodes and operand kinds.
#[test]
fn variety_bytecode_decode() {
    let index = ChunkIndex::parse(VARIETY).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &VARIETY[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    let bc = code.entry_bytecode(0, VARIETY).unwrap();
    let instructions = decode::decode(bc).unwrap();

    assert_eq!(instructions.len(), 10);

    // Push f64 3.14
    assert_eq!(instructions[0].opcode, Opcode::Push);
    assert_eq!(instructions[0].type1, DataType::Double);
    assert!(matches!(instructions[0].operand, Operand::Double(v) if (v - 1.5).abs() < 1e-12));

    // Push i32 100
    assert_eq!(instructions[1].opcode, Opcode::Push);
    assert_eq!(instructions[1].type1, DataType::Int32);
    assert!(matches!(instructions[1].operand, Operand::Int32(100)));

    // PushI i16 -1 (inline)
    assert_eq!(instructions[2].opcode, Opcode::PushI);
    assert_eq!(instructions[2].type1, DataType::Int16);
    assert!(matches!(instructions[2].operand, Operand::Int16(-1)));

    // Push String index 0
    assert_eq!(instructions[3].opcode, Opcode::Push);
    assert_eq!(instructions[3].type1, DataType::String);
    assert!(matches!(instructions[3].operand, Operand::StringIndex(0)));

    // Push Variable Own[0]
    assert_eq!(instructions[4].opcode, Opcode::Push);
    assert_eq!(instructions[4].type1, DataType::Variable);
    let Operand::Variable { var_ref, instance } = &instructions[4].operand else {
        panic!("expected Variable operand");
    };
    assert_eq!(var_ref.variable_id, 0);
    assert_eq!(*instance, -1); // Own

    // Cmp Less
    assert_eq!(instructions[5].opcode, Opcode::Cmp);
    use datawin::bytecode::types::ComparisonKind;
    assert!(matches!(instructions[5].operand, Operand::Comparison(ComparisonKind::Less)));

    // Bf +8 bytes
    assert_eq!(instructions[6].opcode, Opcode::Bf);
    assert!(matches!(instructions[6].operand, Operand::Branch(8)));

    // Dup(0)
    assert_eq!(instructions[7].opcode, Opcode::Dup);
    assert!(matches!(instructions[7].operand, Operand::Dup(0)));

    // Call func=7, argc=0
    assert_eq!(instructions[8].opcode, Opcode::Call);
    assert!(matches!(
        instructions[8].operand,
        Operand::Call { function_id: 7, argc: 0 }
    ));

    // Ret
    assert_eq!(instructions[9].opcode, Opcode::Ret);
}

/// Bytecode round-trip for the variety fixture.
#[test]
fn variety_bytecode_round_trip() {
    let index = ChunkIndex::parse(VARIETY).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &VARIETY[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    let bc = code.entry_bytecode(0, VARIETY).unwrap();
    let instructions = decode::decode(bc).unwrap();
    let reencoded = datawin::bytecode::encode::encode(&instructions);
    assert_eq!(bc, reencoded.as_slice());
}

/// Function name resolves correctly in the variety fixture.
#[test]
fn variety_code_name() {
    let index = ChunkIndex::parse(VARIETY).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &VARIETY[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();
    assert_eq!(code.entries[0].name.resolve(VARIETY).unwrap(), "gml_Script_variety");
}

// ── v15_break_signals ─────────────────────────────────────────────────────────

/// Break signal instructions decode with correct signal values.
///
/// - signal 0xFFF6 (-10): chknullish — no extra word
/// - signal 0xFFFA (-6):  isstaticok — no extra word
/// - signal 0xFFF5 (-11): pushref    — extra i32 word (type1 = Int32)
#[test]
fn break_signals_decode() {
    let index = ChunkIndex::parse(BREAK_SIGNALS).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &BREAK_SIGNALS[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    let bc = code.entry_bytecode(0, BREAK_SIGNALS).unwrap();
    let instructions = decode::decode(bc).unwrap();

    assert_eq!(instructions.len(), 4);

    // chknullish
    assert_eq!(instructions[0].opcode, Opcode::Break);
    assert_eq!(instructions[0].type1, DataType::Double); // no extra
    let Operand::Break { signal, extra } = &instructions[0].operand else {
        panic!("expected Break operand");
    };
    assert_eq!(*signal, 0xFFF6);
    assert!(extra.is_none());

    // isstaticok
    assert_eq!(instructions[1].opcode, Opcode::Break);
    let Operand::Break { signal, extra } = &instructions[1].operand else {
        panic!("expected Break operand");
    };
    assert_eq!(*signal, 0xFFFA);
    assert!(extra.is_none());

    // pushref with extra
    assert_eq!(instructions[2].opcode, Opcode::Break);
    assert_eq!(instructions[2].type1, DataType::Int32); // extra word present
    let Operand::Break { signal, extra } = &instructions[2].operand else {
        panic!("expected Break operand");
    };
    assert_eq!(*signal, 0xFFF5);
    assert_eq!(*extra, Some(5)); // (type_tag=0, asset_index=5)

    // Ret
    assert_eq!(instructions[3].opcode, Opcode::Ret);
}

/// Break signals bytecode round-trip.
#[test]
fn break_signals_round_trip() {
    let index = ChunkIndex::parse(BREAK_SIGNALS).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &BREAK_SIGNALS[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    let bc = code.entry_bytecode(0, BREAK_SIGNALS).unwrap();
    let instructions = decode::decode(bc).unwrap();
    let reencoded = datawin::bytecode::encode::encode(&instructions);
    assert_eq!(bc, reencoded.as_slice());
}
