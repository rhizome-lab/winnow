//! Fixture-based tests for the datawin parser.
//!
//! Each fixture is a small synthetic `data.win`-format file generated by
//! `src/bin/gen_fixtures.rs` and committed to `tests/fixtures/`. The fixtures
//! serve two purposes:
//!
//!   1. **Regression tests** for the Rust parser — assertions check exact
//!      field values, not just "no panic".
//!   2. **Reference inputs** for Kaitai Struct spec validation — run
//!      `tests/kaitai_validate.py` after compiling the .ksy files to Python
//!      (`ksc -t python game_maker_data.ksy gml_bytecode.ksy`).
//!
//! Each .bin fixture is paired with a .json expected-value file documenting
//! the same expected values in a cross-language format. The JSON files are
//! read by `kaitai_validate.py` for automated Kaitai validation.
//!
//! See `src/bin/gen_fixtures.rs` for the generation workflow.

use datawin::bytecode::decode::{self, Operand};
use datawin::bytecode::opcode::Opcode;
use datawin::bytecode::types::DataType;
use datawin::chunks::audo::Audo;
use datawin::chunks::bgnd::Bgnd;
use datawin::chunks::code::Code;
use datawin::chunks::font::Font;
use datawin::chunks::func::Func;
use datawin::chunks::gen8::Gen8;
use datawin::chunks::glob::Glob;
use datawin::chunks::lang::Lang;
use datawin::chunks::objt::Objt;
use datawin::chunks::optn::Optn;
use datawin::chunks::room::Room;
use datawin::chunks::scpt::Scpt;
use datawin::chunks::seqn::Seqn;
use datawin::chunks::shdr::Shdr;
use datawin::chunks::sond::Sond;
use datawin::chunks::sprt::Sprt;
use datawin::chunks::tpag::Tpag;
use datawin::chunks::txtr::Txtr;
use datawin::chunks::vari::Vari;
use datawin::reader::ChunkIndex;
use datawin::string_table::StringTable;
use datawin::version::BytecodeVersion;
use datawin::writer::{assemble_form, extract_chunks};

// ── Fixture bytes ─────────────────────────────────────────────────────────────

static MINIMAL: &[u8] = include_bytes!("fixtures/v15_minimal.bin");
static VARIETY: &[u8] = include_bytes!("fixtures/v15_bytecode_variety.bin");
static BREAK_SIGNALS: &[u8] = include_bytes!("fixtures/v15_break_signals.bin");
static V14_MINIMAL: &[u8] = include_bytes!("fixtures/v14_minimal.bin");
static VARI_FUNC: &[u8] = include_bytes!("fixtures/v15_vari_func.bin");
static MORE_OPCODES: &[u8] = include_bytes!("fixtures/v15_more_opcodes.bin");
static SCPT: &[u8] = include_bytes!("fixtures/v15_scpt.bin");
static SHARED_BLOB: &[u8] = include_bytes!("fixtures/v15_shared_blob.bin");
static SIMPLE_CHUNKS: &[u8] = include_bytes!("fixtures/v15_simple_chunks.bin");
static SOND_AUDO: &[u8] = include_bytes!("fixtures/v15_sond_audo.bin");
static SPRT_TPAG_TXTR: &[u8] = include_bytes!("fixtures/v15_sprt_tpag_txtr.bin");
static OPTN: &[u8] = include_bytes!("fixtures/v15_optn.bin");
static FONT_FIXTURE: &[u8] = include_bytes!("fixtures/v15_font.bin");
static OBJT_FIXTURE: &[u8] = include_bytes!("fixtures/v15_objt.bin");
static ROOM_FIXTURE: &[u8] = include_bytes!("fixtures/v15_room.bin");

// ── JSON expected-value files ─────────────────────────────────────────────────

static JSON_MINIMAL: &str = include_str!("fixtures/v15_minimal.json");
static JSON_VARIETY: &str = include_str!("fixtures/v15_bytecode_variety.json");
static JSON_BREAK_SIGNALS: &str = include_str!("fixtures/v15_break_signals.json");
static JSON_V14_MINIMAL: &str = include_str!("fixtures/v14_minimal.json");
static JSON_VARI_FUNC: &str = include_str!("fixtures/v15_vari_func.json");
static JSON_MORE_OPCODES: &str = include_str!("fixtures/v15_more_opcodes.json");
static JSON_SCPT: &str = include_str!("fixtures/v15_scpt.json");
static JSON_SHARED_BLOB: &str = include_str!("fixtures/v15_shared_blob.json");
static JSON_SIMPLE_CHUNKS: &str = include_str!("fixtures/v15_simple_chunks.json");
static JSON_SOND_AUDO: &str = include_str!("fixtures/v15_sond_audo.json");
static JSON_SPRT_TPAG_TXTR: &str = include_str!("fixtures/v15_sprt_tpag_txtr.json");
static JSON_OPTN: &str = include_str!("fixtures/v15_optn.json");
static JSON_FONT: &str = include_str!("fixtures/v15_font.json");
static JSON_OBJT: &str = include_str!("fixtures/v15_objt.json");
static JSON_ROOM: &str = include_str!("fixtures/v15_room.json");

// ── JSON helper ───────────────────────────────────────────────────────────────

/// Validate that the JSON file parses cleanly and its `file_size` field
/// matches the actual binary size.
fn check_json_file_size(json: &str, bin: &[u8], fixture_name: &str) {
    let v: serde_json::Value = serde_json::from_str(json)
        .unwrap_or_else(|e| panic!("{fixture_name}.json is invalid JSON: {e}"));
    let expected = v["file_size"].as_u64().unwrap_or_else(|| {
        panic!("{fixture_name}.json missing 'file_size'")
    }) as usize;
    assert_eq!(
        bin.len(),
        expected,
        "{fixture_name}: binary size ({}) != JSON file_size ({})",
        bin.len(),
        expected
    );
}

/// Extract a top-level u64 field from parsed JSON.
fn json_u64(v: &serde_json::Value, path: &str) -> u64 {
    v.pointer(path)
        .and_then(|x| x.as_u64())
        .unwrap_or_else(|| panic!("JSON path {path} missing or not u64"))
}

// ── v15_minimal ───────────────────────────────────────────────────────────────

#[test]
fn minimal_json_file_size() {
    check_json_file_size(JSON_MINIMAL, MINIMAL, "v15_minimal");
}

#[test]
fn minimal_chunk_index() {
    let index = ChunkIndex::parse(MINIMAL).unwrap();
    assert_eq!(index.len(), 3);
    let magics: Vec<&str> = index.chunks().iter().map(|c| c.magic_str()).collect();
    assert_eq!(magics, ["GEN8", "STRG", "CODE"]);
}

#[test]
fn minimal_gen8() {
    let index = ChunkIndex::parse(MINIMAL).unwrap();
    let entry = index.find(b"GEN8").unwrap();
    let gen8 =
        Gen8::parse(&MINIMAL[entry.data_offset()..entry.data_offset() + entry.size]).unwrap();

    assert_eq!(gen8.bytecode_version, BytecodeVersion(15));
    assert_eq!(gen8.game_id, 1);
    assert_eq!(gen8.major, 1);
    assert_eq!(gen8.minor, 0);
    assert!(!gen8.is_debug_disabled);
    assert!(gen8.room_order.is_empty());
    assert!(gen8.gms2_data.is_empty());

    // Validate against JSON
    let v: serde_json::Value = serde_json::from_str(JSON_MINIMAL).unwrap();
    assert_eq!(json_u64(&v, "/gen8/bytecode_version"), 15);
    assert_eq!(json_u64(&v, "/gen8/game_id"), 1);
    assert_eq!(json_u64(&v, "/gen8/major"), 1);
    assert_eq!(json_u64(&v, "/gen8/minor"), 0);
}

#[test]
fn minimal_gen8_string_refs() {
    let index = ChunkIndex::parse(MINIMAL).unwrap();
    let entry = index.find(b"GEN8").unwrap();
    let gen8 =
        Gen8::parse(&MINIMAL[entry.data_offset()..entry.data_offset() + entry.size]).unwrap();

    assert_eq!(gen8.filename.resolve(MINIMAL).unwrap(), "default");
    assert_eq!(gen8.config.resolve(MINIMAL).unwrap(), "default");
    assert_eq!(gen8.name.resolve(MINIMAL).unwrap(), "test_game");
    assert_eq!(gen8.display_name.resolve(MINIMAL).unwrap(), "test_game");
}

#[test]
fn minimal_strg() {
    let index = ChunkIndex::parse(MINIMAL).unwrap();
    let entry = index.find(b"STRG").unwrap();
    let strg_abs = entry.data_offset();
    let strg = StringTable::parse(
        &MINIMAL[strg_abs..strg_abs + entry.size],
        strg_abs,
    )
    .unwrap();

    assert_eq!(strg.len(), 4);
    assert_eq!(strg.get(0, MINIMAL).unwrap(), "");
    assert_eq!(strg.get(1, MINIMAL).unwrap(), "default");
    assert_eq!(strg.get(2, MINIMAL).unwrap(), "test_game");
    assert_eq!(strg.get(3, MINIMAL).unwrap(), "gml_Script_test");
}

#[test]
fn minimal_code_entry() {
    let index = ChunkIndex::parse(MINIMAL).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &MINIMAL[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    assert_eq!(code.entries.len(), 1);
    let e = &code.entries[0];
    assert_eq!(e.name.resolve(MINIMAL).unwrap(), "gml_Script_test");
    assert_eq!(e.locals_count, 0);
    assert_eq!(e.args_count, 0);
}

#[test]
fn minimal_bytecode_decode() {
    let index = ChunkIndex::parse(MINIMAL).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &MINIMAL[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    let bc = code.entry_bytecode(0, MINIMAL).unwrap();
    let instructions = decode::decode(bc).unwrap();

    assert_eq!(instructions.len(), 2);
    assert_eq!(instructions[0].opcode, Opcode::PushI);
    assert_eq!(instructions[0].type1, DataType::Int16);
    assert!(matches!(instructions[0].operand, Operand::Int16(42)));
    assert_eq!(instructions[1].opcode, Opcode::Ret);
    assert!(matches!(instructions[1].operand, Operand::None));
}

#[test]
fn minimal_bytecode_round_trip() {
    let index = ChunkIndex::parse(MINIMAL).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &MINIMAL[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    let bc = code.entry_bytecode(0, MINIMAL).unwrap();
    let instructions = decode::decode(bc).unwrap();
    let reencoded = datawin::bytecode::encode::encode(&instructions);
    assert_eq!(bc, reencoded.as_slice());
}

#[test]
fn minimal_file_round_trip() {
    let index = ChunkIndex::parse(MINIMAL).unwrap();
    let chunks = extract_chunks(&index, MINIMAL);
    let reassembled = assemble_form(&chunks);
    assert_eq!(MINIMAL, reassembled.as_slice());
}

// ── v15_bytecode_variety ──────────────────────────────────────────────────────

#[test]
fn variety_json_file_size() {
    check_json_file_size(JSON_VARIETY, VARIETY, "v15_bytecode_variety");
}

#[test]
fn variety_bytecode_decode() {
    let index = ChunkIndex::parse(VARIETY).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &VARIETY[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    let bc = code.entry_bytecode(0, VARIETY).unwrap();
    let instructions = decode::decode(bc).unwrap();

    assert_eq!(instructions.len(), 10);

    assert_eq!(instructions[0].opcode, Opcode::Push);
    assert_eq!(instructions[0].type1, DataType::Double);
    assert!(matches!(instructions[0].operand, Operand::Double(v) if (v - 1.5).abs() < 1e-12));

    assert_eq!(instructions[1].opcode, Opcode::Push);
    assert_eq!(instructions[1].type1, DataType::Int32);
    assert!(matches!(instructions[1].operand, Operand::Int32(100)));

    assert_eq!(instructions[2].opcode, Opcode::PushI);
    assert_eq!(instructions[2].type1, DataType::Int16);
    assert!(matches!(instructions[2].operand, Operand::Int16(-1)));

    assert_eq!(instructions[3].opcode, Opcode::Push);
    assert_eq!(instructions[3].type1, DataType::String);
    assert!(matches!(instructions[3].operand, Operand::StringIndex(0)));

    assert_eq!(instructions[4].opcode, Opcode::Push);
    assert_eq!(instructions[4].type1, DataType::Variable);
    let Operand::Variable { var_ref, instance } = &instructions[4].operand else {
        panic!("expected Variable operand");
    };
    assert_eq!(var_ref.variable_id, 0);
    assert_eq!(*instance, -1);

    assert_eq!(instructions[5].opcode, Opcode::Cmp);
    use datawin::bytecode::types::ComparisonKind;
    assert!(matches!(instructions[5].operand, Operand::Comparison(ComparisonKind::Less)));

    assert_eq!(instructions[6].opcode, Opcode::Bf);
    assert!(matches!(instructions[6].operand, Operand::Branch(8)));

    assert_eq!(instructions[7].opcode, Opcode::Dup);
    assert!(matches!(instructions[7].operand, Operand::Dup(0)));

    assert_eq!(instructions[8].opcode, Opcode::Call);
    assert!(matches!(
        instructions[8].operand,
        Operand::Call { function_id: 7, argc: 0 }
    ));

    assert_eq!(instructions[9].opcode, Opcode::Ret);
}

#[test]
fn variety_bytecode_round_trip() {
    let index = ChunkIndex::parse(VARIETY).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &VARIETY[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    let bc = code.entry_bytecode(0, VARIETY).unwrap();
    let instructions = decode::decode(bc).unwrap();
    let reencoded = datawin::bytecode::encode::encode(&instructions);
    assert_eq!(bc, reencoded.as_slice());
}

#[test]
fn variety_code_name() {
    let index = ChunkIndex::parse(VARIETY).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &VARIETY[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();
    assert_eq!(code.entries[0].name.resolve(VARIETY).unwrap(), "gml_Script_variety");
}

// ── v15_break_signals ─────────────────────────────────────────────────────────

#[test]
fn break_signals_json_file_size() {
    check_json_file_size(JSON_BREAK_SIGNALS, BREAK_SIGNALS, "v15_break_signals");
}

#[test]
fn break_signals_decode() {
    let index = ChunkIndex::parse(BREAK_SIGNALS).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &BREAK_SIGNALS[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    let bc = code.entry_bytecode(0, BREAK_SIGNALS).unwrap();
    let instructions = decode::decode(bc).unwrap();

    assert_eq!(instructions.len(), 4);

    assert_eq!(instructions[0].opcode, Opcode::Break);
    assert_eq!(instructions[0].type1, DataType::Double);
    let Operand::Break { signal, extra } = &instructions[0].operand else {
        panic!("expected Break operand");
    };
    assert_eq!(*signal, 0xFFF6);
    assert!(extra.is_none());

    assert_eq!(instructions[1].opcode, Opcode::Break);
    let Operand::Break { signal, extra } = &instructions[1].operand else {
        panic!("expected Break operand");
    };
    assert_eq!(*signal, 0xFFFA);
    assert!(extra.is_none());

    assert_eq!(instructions[2].opcode, Opcode::Break);
    assert_eq!(instructions[2].type1, DataType::Int32);
    let Operand::Break { signal, extra } = &instructions[2].operand else {
        panic!("expected Break operand");
    };
    assert_eq!(*signal, 0xFFF5);
    assert_eq!(*extra, Some(5));

    assert_eq!(instructions[3].opcode, Opcode::Ret);
}

#[test]
fn break_signals_round_trip() {
    let index = ChunkIndex::parse(BREAK_SIGNALS).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &BREAK_SIGNALS[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    let bc = code.entry_bytecode(0, BREAK_SIGNALS).unwrap();
    let instructions = decode::decode(bc).unwrap();
    let reencoded = datawin::bytecode::encode::encode(&instructions);
    assert_eq!(bc, reencoded.as_slice());
}

// ── v14_minimal ───────────────────────────────────────────────────────────────

#[test]
fn v14_json_file_size() {
    check_json_file_size(JSON_V14_MINIMAL, V14_MINIMAL, "v14_minimal");
}

/// BC=14: GEN8 reports bytecode_version = 14.
#[test]
fn v14_gen8() {
    let index = ChunkIndex::parse(V14_MINIMAL).unwrap();
    let entry = index.find(b"GEN8").unwrap();
    let gen8 =
        Gen8::parse(&V14_MINIMAL[entry.data_offset()..entry.data_offset() + entry.size]).unwrap();

    assert_eq!(gen8.bytecode_version, BytecodeVersion(14));
    assert_eq!(gen8.game_id, 1);
    assert_eq!(gen8.major, 1);
    assert_eq!(gen8.name.resolve(V14_MINIMAL).unwrap(), "v14_game");
}

/// BC=14: chunks in order GEN8, STRG, CODE, VARI, FUNC.
#[test]
fn v14_chunk_index() {
    let index = ChunkIndex::parse(V14_MINIMAL).unwrap();
    assert_eq!(index.len(), 5);
    let magics: Vec<&str> = index.chunks().iter().map(|c| c.magic_str()).collect();
    assert_eq!(magics, ["GEN8", "STRG", "CODE", "VARI", "FUNC"]);
}

/// BC=14 CODE: simple format — bytecode immediately follows name+length header.
///   - `locals_count = 0`, `args_count = 0` (v14 format has no such fields)
///   - `bytecode_offset = ptr + 8`
#[test]
fn v14_code_entry() {
    let index = ChunkIndex::parse(V14_MINIMAL).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &V14_MINIMAL[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(14),
    )
    .unwrap();

    assert_eq!(code.entries.len(), 1);
    let e = &code.entries[0];
    assert_eq!(e.name.resolve(V14_MINIMAL).unwrap(), "gml_Script_init");
    assert_eq!(e.locals_count, 0);
    assert_eq!(e.args_count, 0);
    assert_eq!(e.length, 4); // one 4-byte instruction

    // Verify bytecode_offset points into the file and the raw bytes are correct.
    let bc = code.entry_bytecode(0, V14_MINIMAL).unwrap();
    assert_eq!(bc.len(), 4);
    assert_eq!(bc[0], 0x9D, "expected v14 Ret opcode (0x9D)");
}

/// BC=14 VARI: no header, 12-byte entries; `instance_type` and `var_id`
/// default to 0 (not present in the format).
#[test]
fn v14_vari() {
    let index = ChunkIndex::parse(V14_MINIMAL).unwrap();
    let entry = index.find(b"VARI").unwrap();
    let vari = Vari::parse(
        &V14_MINIMAL[entry.data_offset()..entry.data_offset() + entry.size],
        BytecodeVersion(14),
    )
    .unwrap();

    // v14 header fields default to 0.
    assert_eq!(vari.instance_var_count, 0);
    assert_eq!(vari.instance_var_count_max, 0);
    assert_eq!(vari.max_local_var_count, 0);

    assert_eq!(vari.variables.len(), 2);
    assert_eq!(vari.variables[0].name.resolve(V14_MINIMAL).unwrap(), "x");
    assert_eq!(vari.variables[0].occurrences, 2);
    assert_eq!(vari.variables[0].first_address, -1);
    assert_eq!(vari.variables[1].name.resolve(V14_MINIMAL).unwrap(), "y");
    assert_eq!(vari.variables[1].occurrences, 1);
}

/// BC=14 FUNC: flat list (no count prefix); `code_locals` is empty.
#[test]
fn v14_func() {
    let index = ChunkIndex::parse(V14_MINIMAL).unwrap();
    let entry = index.find(b"FUNC").unwrap();
    let func = Func::parse(
        &V14_MINIMAL[entry.data_offset()..entry.data_offset() + entry.size],
        BytecodeVersion(14),
    )
    .unwrap();

    assert_eq!(func.functions.len(), 1);
    assert_eq!(func.functions[0].name.resolve(V14_MINIMAL).unwrap(), "gml_Script_init");
    assert_eq!(func.functions[0].occurrences, 1);
    assert_eq!(func.functions[0].first_address, -1);
    assert!(func.code_locals.is_empty());
}

// ── v15_vari_func ─────────────────────────────────────────────────────────────

#[test]
fn vari_func_json_file_size() {
    check_json_file_size(JSON_VARI_FUNC, VARI_FUNC, "v15_vari_func");
}

/// BC=15 VARI: 3-field header + 20-byte entries with instance_type and var_id.
#[test]
fn vari_func_vari_v15() {
    let index = ChunkIndex::parse(VARI_FUNC).unwrap();
    let entry = index.find(b"VARI").unwrap();
    let vari = Vari::parse(
        &VARI_FUNC[entry.data_offset()..entry.data_offset() + entry.size],
        BytecodeVersion(15),
    )
    .unwrap();

    assert_eq!(vari.instance_var_count, 1);
    assert_eq!(vari.instance_var_count_max, 1);
    assert_eq!(vari.max_local_var_count, 1);

    assert_eq!(vari.variables.len(), 1);
    let v = &vari.variables[0];
    assert_eq!(v.name.resolve(VARI_FUNC).unwrap(), "x");
    assert_eq!(v.instance_type, -1); // Own
    assert_eq!(v.var_id, 0);
    assert_eq!(v.occurrences, 1);
    assert_eq!(v.first_address, -1);
}

/// BC=15 FUNC: count-prefixed functions + CodeLocals section.
#[test]
fn vari_func_func_v15() {
    let index = ChunkIndex::parse(VARI_FUNC).unwrap();
    let entry = index.find(b"FUNC").unwrap();
    let func = Func::parse(
        &VARI_FUNC[entry.data_offset()..entry.data_offset() + entry.size],
        BytecodeVersion(15),
    )
    .unwrap();

    assert_eq!(func.functions.len(), 1);
    assert_eq!(func.functions[0].name.resolve(VARI_FUNC).unwrap(), "my_func");
    assert_eq!(func.functions[0].occurrences, 1);
    assert_eq!(func.functions[0].first_address, -1);

    assert_eq!(func.code_locals.len(), 1);
    let cl = &func.code_locals[0];
    assert_eq!(cl.name.resolve(VARI_FUNC).unwrap(), "gml_Script_vf");
    assert_eq!(cl.locals.len(), 1);
    assert_eq!(cl.locals[0].index, 0);
    assert_eq!(cl.locals[0].name.resolve(VARI_FUNC).unwrap(), "i");
}

/// CODE entry in the vari_func fixture has locals_count = 1.
#[test]
fn vari_func_code_locals_count() {
    let index = ChunkIndex::parse(VARI_FUNC).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &VARI_FUNC[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    assert_eq!(code.entries.len(), 1);
    let e = &code.entries[0];
    assert_eq!(e.name.resolve(VARI_FUNC).unwrap(), "gml_Script_vf");
    assert_eq!(e.locals_count, 1);
    assert_eq!(e.args_count, 0);
}

// ── v15_more_opcodes ──────────────────────────────────────────────────────────

#[test]
fn more_opcodes_json_file_size() {
    check_json_file_size(JSON_MORE_OPCODES, MORE_OPCODES, "v15_more_opcodes");
}

/// Push.Float, Push.Int64, Push.Bool, PushLoc/Glb/Bltn, Pop.Variable,
/// backward Bf branch — all decode correctly and round-trip.
#[test]
fn more_opcodes_decode() {
    let index = ChunkIndex::parse(MORE_OPCODES).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &MORE_OPCODES[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    let bc = code.entry_bytecode(0, MORE_OPCODES).unwrap();
    let instructions = decode::decode(bc).unwrap();

    assert_eq!(instructions.len(), 9);

    // 0: Push.Float 2.5
    assert_eq!(instructions[0].opcode, Opcode::Push);
    assert_eq!(instructions[0].type1, DataType::Float);
    assert!(matches!(instructions[0].operand, Operand::Float(v) if (v - 2.5_f32).abs() < 1e-6));

    // 1: Push.Int64 999
    assert_eq!(instructions[1].opcode, Opcode::Push);
    assert_eq!(instructions[1].type1, DataType::Int64);
    assert!(matches!(instructions[1].operand, Operand::Int64(999)));

    // 2: Push.Bool true
    assert_eq!(instructions[2].opcode, Opcode::Push);
    assert_eq!(instructions[2].type1, DataType::Bool);
    assert!(matches!(instructions[2].operand, Operand::Bool(true)));

    // 3: PushLoc.Variable Own[0]
    assert_eq!(instructions[3].opcode, Opcode::PushLoc);
    assert_eq!(instructions[3].type1, DataType::Variable);
    let Operand::Variable { var_ref, instance } = &instructions[3].operand else {
        panic!("expected Variable");
    };
    assert_eq!(var_ref.variable_id, 0);
    assert_eq!(*instance, -1); // Own

    // 4: PushGlb.Variable Global[0]
    assert_eq!(instructions[4].opcode, Opcode::PushGlb);
    let Operand::Variable { instance, .. } = &instructions[4].operand else {
        panic!("expected Variable");
    };
    assert_eq!(*instance, -5); // Global

    // 5: PushBltn.Variable Builtin[0]
    assert_eq!(instructions[5].opcode, Opcode::PushBltn);
    let Operand::Variable { instance, .. } = &instructions[5].operand else {
        panic!("expected Variable");
    };
    assert_eq!(*instance, -6); // Builtin

    // 6: Pop.Variable Own[1]
    assert_eq!(instructions[6].opcode, Opcode::Pop);
    let Operand::Variable { var_ref, instance } = &instructions[6].operand else {
        panic!("expected Variable");
    };
    assert_eq!(var_ref.variable_id, 1);
    assert_eq!(*instance, -1); // Own

    // 7: Bf -60 (backward branch)
    assert_eq!(instructions[7].opcode, Opcode::Bf);
    assert!(matches!(instructions[7].operand, Operand::Branch(-60)));

    // 8: Ret
    assert_eq!(instructions[8].opcode, Opcode::Ret);
}

#[test]
fn more_opcodes_round_trip() {
    let index = ChunkIndex::parse(MORE_OPCODES).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &MORE_OPCODES[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    let bc = code.entry_bytecode(0, MORE_OPCODES).unwrap();
    let instructions = decode::decode(bc).unwrap();
    let reencoded = datawin::bytecode::encode::encode(&instructions);
    assert_eq!(bc, reencoded.as_slice());
}

// ── v15_scpt ──────────────────────────────────────────────────────────────────

#[test]
fn scpt_json_file_size() {
    check_json_file_size(JSON_SCPT, SCPT, "v15_scpt");
}

/// SCPT chunk: 1 script entry with name "Script_foo" mapping to code_id 0.
#[test]
fn scpt_parse() {
    let index = ChunkIndex::parse(SCPT).unwrap();
    assert_eq!(index.len(), 4);
    let magics: Vec<&str> = index.chunks().iter().map(|c| c.magic_str()).collect();
    assert_eq!(magics, ["GEN8", "STRG", "CODE", "SCPT"]);

    let entry = index.find(b"SCPT").unwrap();
    let scpt_abs = entry.data_offset();
    let scpt = Scpt::parse(
        &SCPT[scpt_abs..scpt_abs + entry.size],
        scpt_abs,
        SCPT,
    )
    .unwrap();

    assert_eq!(scpt.scripts.len(), 1);
    assert_eq!(scpt.scripts[0].name.resolve(SCPT).unwrap(), "Script_foo");
    assert_eq!(scpt.scripts[0].code_id, 0);
}

/// SCPT name is independent from the CODE entry name.
#[test]
fn scpt_code_entry_name() {
    let index = ChunkIndex::parse(SCPT).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &SCPT[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    assert_eq!(code.entries.len(), 1);
    assert_eq!(code.entries[0].name.resolve(SCPT).unwrap(), "gml_Script_foo");
}

// ── v15_shared_blob ───────────────────────────────────────────────────────────

#[test]
fn shared_blob_json_file_size() {
    check_json_file_size(JSON_SHARED_BLOB, SHARED_BLOB, "v15_shared_blob");
}

/// GMS2.3+ shared blob: two CODE entries decode with correct separate lengths.
///
/// The two-pass gap algorithm must compute:
///   - parent: length = 8 bytes (PushI + Ret)
///   - child:  length = 4 bytes (Ret)
#[test]
fn shared_blob_code_entries() {
    let index = ChunkIndex::parse(SHARED_BLOB).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &SHARED_BLOB[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    assert_eq!(code.entries.len(), 2);

    let parent = &code.entries[0];
    assert_eq!(parent.name.resolve(SHARED_BLOB).unwrap(), "gml_Script_parent");
    assert_eq!(parent.length, 8); // PushI + Ret = 8 bytes
    assert_eq!(parent.locals_count, 0);

    let child = &code.entries[1];
    assert_eq!(child.name.resolve(SHARED_BLOB).unwrap(), "gml_Script_child");
    assert_eq!(child.length, 4); // Ret = 4 bytes
    assert_eq!(child.locals_count, 0);

    // Parent and child have different bytecode offsets but the same blob.
    assert_ne!(parent.bytecode_offset, child.bytecode_offset);
    assert_eq!(child.bytecode_offset, parent.bytecode_offset + 8);
}

/// Both shared-blob entries decode and round-trip correctly.
#[test]
fn shared_blob_bytecode_decode() {
    let index = ChunkIndex::parse(SHARED_BLOB).unwrap();
    let entry = index.find(b"CODE").unwrap();
    let code_abs = entry.data_offset();
    let code = Code::parse(
        &SHARED_BLOB[code_abs..code_abs + entry.size],
        code_abs,
        BytecodeVersion(15),
    )
    .unwrap();

    // Parent: PushI Int16(1) + Ret
    let parent_bc = code.entry_bytecode(0, SHARED_BLOB).unwrap();
    let parent_instrs = decode::decode(parent_bc).unwrap();
    assert_eq!(parent_instrs.len(), 2);
    assert_eq!(parent_instrs[0].opcode, Opcode::PushI);
    assert!(matches!(parent_instrs[0].operand, Operand::Int16(1)));
    assert_eq!(parent_instrs[1].opcode, Opcode::Ret);

    // Child: Ret
    let child_bc = code.entry_bytecode(1, SHARED_BLOB).unwrap();
    let child_instrs = decode::decode(child_bc).unwrap();
    assert_eq!(child_instrs.len(), 1);
    assert_eq!(child_instrs[0].opcode, Opcode::Ret);

    // Round-trips
    let re_parent = datawin::bytecode::encode::encode(&parent_instrs);
    assert_eq!(parent_bc, re_parent.as_slice());
    let re_child = datawin::bytecode::encode::encode(&child_instrs);
    assert_eq!(child_bc, re_child.as_slice());
}

// ── v15_simple_chunks ─────────────────────────────────────────────────────────

#[test]
fn simple_chunks_json_file_size() {
    check_json_file_size(JSON_SIMPLE_CHUNKS, SIMPLE_CHUNKS, "v15_simple_chunks");
}

#[test]
fn simple_chunks_glob() {
    let index = ChunkIndex::parse(SIMPLE_CHUNKS).unwrap();
    let entry = index.find(b"GLOB").unwrap();
    let glob = Glob::parse(&SIMPLE_CHUNKS[entry.data_offset()..entry.data_offset() + entry.size])
        .unwrap();
    assert_eq!(glob.script_ids.len(), 1);
    assert_eq!(glob.script_ids[0], 0);

    let v: serde_json::Value = serde_json::from_str(JSON_SIMPLE_CHUNKS).unwrap();
    assert_eq!(json_u64(&v, "/glob/count"), 1);
    assert_eq!(json_u64(&v, "/glob/script_ids/0"), 0);
}

#[test]
fn simple_chunks_lang() {
    let index = ChunkIndex::parse(SIMPLE_CHUNKS).unwrap();
    let entry = index.find(b"LANG").unwrap();
    let lang = Lang::parse(&SIMPLE_CHUNKS[entry.data_offset()..entry.data_offset() + entry.size])
        .unwrap();
    assert_eq!(lang.entry_count, 1);
    assert_eq!(lang.entries.len(), 1);
    assert_eq!(lang.entries[0].name.resolve(SIMPLE_CHUNKS).unwrap(), "English");
    assert_eq!(lang.entries[0].region.resolve(SIMPLE_CHUNKS).unwrap(), "en");

    let v: serde_json::Value = serde_json::from_str(JSON_SIMPLE_CHUNKS).unwrap();
    assert_eq!(json_u64(&v, "/lang/entry_count"), 1);
    assert_eq!(json_u64(&v, "/lang/count"), 1);
}

#[test]
fn simple_chunks_shdr() {
    let index = ChunkIndex::parse(SIMPLE_CHUNKS).unwrap();
    let entry = index.find(b"SHDR").unwrap();
    let shdr =
        Shdr::parse(&SIMPLE_CHUNKS[entry.data_offset()..entry.data_offset() + entry.size], SIMPLE_CHUNKS)
            .unwrap();
    assert_eq!(shdr.shaders.len(), 1);
    assert_eq!(shdr.shaders[0].name.resolve(SIMPLE_CHUNKS).unwrap(), "shader_name");
}

#[test]
fn simple_chunks_bgnd() {
    let index = ChunkIndex::parse(SIMPLE_CHUNKS).unwrap();
    let entry = index.find(b"BGND").unwrap();
    let bgnd =
        Bgnd::parse(&SIMPLE_CHUNKS[entry.data_offset()..entry.data_offset() + entry.size], SIMPLE_CHUNKS)
            .unwrap();
    assert_eq!(bgnd.backgrounds.len(), 1);
    assert_eq!(bgnd.backgrounds[0].name.resolve(SIMPLE_CHUNKS).unwrap(), "bg_name");
}

#[test]
fn simple_chunks_seqn() {
    let index = ChunkIndex::parse(SIMPLE_CHUNKS).unwrap();
    let entry = index.find(b"SEQN").unwrap();
    let seqn =
        Seqn::parse(&SIMPLE_CHUNKS[entry.data_offset()..entry.data_offset() + entry.size], SIMPLE_CHUNKS)
            .unwrap();
    assert_eq!(seqn.sequences.len(), 1);
    assert_eq!(seqn.sequences[0].name.resolve(SIMPLE_CHUNKS).unwrap(), "sequence_name");

    let v: serde_json::Value = serde_json::from_str(JSON_SIMPLE_CHUNKS).unwrap();
    assert_eq!(json_u64(&v, "/seqn/version"), 1);
}

#[test]
fn simple_chunks_chunk_list() {
    let index = ChunkIndex::parse(SIMPLE_CHUNKS).unwrap();
    let magics: Vec<&str> = index.chunks().iter().map(|c| c.magic_str()).collect();
    assert_eq!(magics, ["GEN8", "STRG", "GLOB", "LANG", "SHDR", "BGND", "SEQN"]);
}

// ── v15_sond_audo ─────────────────────────────────────────────────────────────

#[test]
fn sond_audo_json_file_size() {
    check_json_file_size(JSON_SOND_AUDO, SOND_AUDO, "v15_sond_audo");
}

#[test]
fn sond_audo_sond() {
    let index = ChunkIndex::parse(SOND_AUDO).unwrap();
    let entry = index.find(b"SOND").unwrap();
    let sond =
        Sond::parse(&SOND_AUDO[entry.data_offset()..entry.data_offset() + entry.size], SOND_AUDO)
            .unwrap();

    assert_eq!(sond.sounds.len(), 1);
    let s = &sond.sounds[0];
    assert_eq!(s.name.resolve(SOND_AUDO).unwrap(), "explosion");
    assert_eq!(s.flags, 0);
    assert_eq!(s.type_name.resolve(SOND_AUDO).unwrap(), ".wav");
    assert_eq!(s.file_name.resolve(SOND_AUDO).unwrap(), "explosion.wav");
    assert_eq!(s.effects, 0);
    assert!((s.volume - 1.0).abs() < 1e-6);
    assert!((s.pitch - 1.0).abs() < 1e-6);
    assert_eq!(s.group_id, -1);
    assert_eq!(s.audio_id, 0);

    let v: serde_json::Value = serde_json::from_str(JSON_SOND_AUDO).unwrap();
    assert_eq!(json_u64(&v, "/sond/count"), 1);
    assert_eq!(json_u64(&v, "/sond/entries/0/flags"), 0);
    assert_eq!(json_u64(&v, "/sond/entries/0/audio_id"), 0);
}

#[test]
fn sond_audo_audo() {
    let index = ChunkIndex::parse(SOND_AUDO).unwrap();
    let entry = index.find(b"AUDO").unwrap();
    let audo_abs = entry.data_offset();
    let audo =
        Audo::parse(&SOND_AUDO[audo_abs..audo_abs + entry.size], audo_abs).unwrap();

    assert_eq!(audo.entries.len(), 1);
    assert_eq!(audo.entries[0].length, 4);

    // Audio data is 4 zero bytes.
    let audio = audo.audio_data(0, SOND_AUDO).unwrap();
    assert_eq!(audio.len(), 4);
    assert_eq!(audio, &[0u8, 0, 0, 0]);

    let v: serde_json::Value = serde_json::from_str(JSON_SOND_AUDO).unwrap();
    assert_eq!(json_u64(&v, "/audo/count"), 1);
    assert_eq!(json_u64(&v, "/audo/entries/0/length"), 4);
}

// ── v15_sprt_tpag_txtr ────────────────────────────────────────────────────────

#[test]
fn sprt_tpag_txtr_json_file_size() {
    check_json_file_size(JSON_SPRT_TPAG_TXTR, SPRT_TPAG_TXTR, "v15_sprt_tpag_txtr");
}

#[test]
fn sprt_tpag_txtr_txtr() {
    let index = ChunkIndex::parse(SPRT_TPAG_TXTR).unwrap();
    let entry = index.find(b"TXTR").unwrap();
    let txtr = Txtr::parse(
        &SPRT_TPAG_TXTR[entry.data_offset()..entry.data_offset() + entry.size],
        SPRT_TPAG_TXTR,
    )
    .unwrap();

    // 2 GMS1-format entries (pointer spacing = 8, not > 12 → is_gms2=false)
    assert_eq!(txtr.textures.len(), 2);
    assert!(txtr.textures[0].gms2_fields.is_none());
    assert!(txtr.textures[1].gms2_fields.is_none());
    // data_offset values encoded in the fixture (0xDEAD and 0xBEEF)
    assert_eq!(txtr.textures[0].data_offset, 0xDEAD);
    assert_eq!(txtr.textures[1].data_offset, 0xBEEF);
}

#[test]
fn sprt_tpag_txtr_tpag() {
    let index = ChunkIndex::parse(SPRT_TPAG_TXTR).unwrap();
    let entry = index.find(b"TPAG").unwrap();
    let tpag = Tpag::parse(
        &SPRT_TPAG_TXTR[entry.data_offset()..entry.data_offset() + entry.size],
        SPRT_TPAG_TXTR,
    )
    .unwrap();

    assert_eq!(tpag.items.len(), 1);
    let item = &tpag.items[0];
    assert_eq!(item.source_width, 16);
    assert_eq!(item.source_height, 16);
    assert_eq!(item.render_width, 16);
    assert_eq!(item.render_height, 16);
    assert_eq!(item.texture_page_id, 0);

    let v: serde_json::Value = serde_json::from_str(JSON_SPRT_TPAG_TXTR).unwrap();
    assert_eq!(json_u64(&v, "/tpag/count"), 1);
    assert_eq!(json_u64(&v, "/tpag/entries/0/render_width"), 16);
    assert_eq!(json_u64(&v, "/tpag/entries/0/texture_page_id"), 0);
}

#[test]
fn sprt_tpag_txtr_sprt() {
    let index = ChunkIndex::parse(SPRT_TPAG_TXTR).unwrap();
    let entry = index.find(b"SPRT").unwrap();
    let sprt = Sprt::parse(
        &SPRT_TPAG_TXTR[entry.data_offset()..entry.data_offset() + entry.size],
        SPRT_TPAG_TXTR,
    )
    .unwrap();

    assert_eq!(sprt.sprites.len(), 1);
    let s = &sprt.sprites[0];
    assert_eq!(s.name.resolve(SPRT_TPAG_TXTR).unwrap(), "spr_player");
    assert_eq!(s.width, 16);
    assert_eq!(s.height, 16);
    assert_eq!(s.origin_x, 8);
    assert_eq!(s.origin_y, 8);
    assert_eq!(s.tpag_indices.len(), 1);
    // tpag_indices stores absolute file offsets; the TPAG entry is at data_offset+8.
    let tpag_entry = index.find(b"TPAG").unwrap();
    let expected_tpag_abs = (tpag_entry.data_offset() + 8) as u32;
    assert_eq!(s.tpag_indices[0], expected_tpag_abs);

    let v: serde_json::Value = serde_json::from_str(JSON_SPRT_TPAG_TXTR).unwrap();
    assert_eq!(json_u64(&v, "/sprt/count"), 1);
    assert_eq!(json_u64(&v, "/sprt/entries/0/width"), 16);
    assert_eq!(json_u64(&v, "/sprt/entries/0/tpag_count"), 1);
}

// ── v15_optn ──────────────────────────────────────────────────────────────────

#[test]
fn optn_json_file_size() {
    check_json_file_size(JSON_OPTN, OPTN, "v15_optn");
}

#[test]
fn optn_parse() {
    let index = ChunkIndex::parse(OPTN).unwrap();
    let entry = index.find(b"OPTN").unwrap();
    let optn =
        Optn::parse(&OPTN[entry.data_offset()..entry.data_offset() + entry.size]).unwrap();

    assert_eq!(optn.flags, 0);
    assert_eq!(optn.constants.len(), 1);
    assert_eq!(optn.constants[0].name.resolve(OPTN).unwrap(), "my_const");
    assert_eq!(optn.constants[0].value.resolve(OPTN).unwrap(), "42");

    let v: serde_json::Value = serde_json::from_str(JSON_OPTN).unwrap();
    assert_eq!(json_u64(&v, "/optn/flags"), 0);
    assert_eq!(json_u64(&v, "/optn/constant_count"), 1);
}

// ── v15_font ──────────────────────────────────────────────────────────────────

#[test]
fn font_json_file_size() {
    check_json_file_size(JSON_FONT, FONT_FIXTURE, "v15_font");
}

#[test]
fn font_parse() {
    let index = ChunkIndex::parse(FONT_FIXTURE).unwrap();
    let entry = index.find(b"FONT").unwrap();
    let font =
        Font::parse(&FONT_FIXTURE[entry.data_offset()..entry.data_offset() + entry.size], FONT_FIXTURE)
            .unwrap();

    assert_eq!(font.fonts.len(), 1);
    let f = &font.fonts[0];
    assert_eq!(f.name.resolve(FONT_FIXTURE).unwrap(), "fnt_main");
    assert_eq!(f.display_name.resolve(FONT_FIXTURE).unwrap(), "Arial");
    assert_eq!(f.size, 12);
    assert!(!f.bold);
    assert!(!f.italic);
    assert_eq!(f.range_start, 32);
    assert_eq!(f.charset, 0);
    assert_eq!(f.antialias, 2);
    assert_eq!(f.range_end, 127);
    assert_eq!(f.tpag_index, 0);
    assert!((f.scale_x - 1.0).abs() < 1e-6);
    assert!((f.scale_y - 1.0).abs() < 1e-6);

    assert_eq!(f.glyphs.len(), 1);
    let g = &f.glyphs[0];
    assert_eq!(g.character, 65); // 'A'
    assert_eq!(g.x, 10);
    assert_eq!(g.y, 0);
    assert_eq!(g.width, 8);
    assert_eq!(g.height, 12);
    assert_eq!(g.shift, 9);
    assert_eq!(g.offset, 0);

    let v: serde_json::Value = serde_json::from_str(JSON_FONT).unwrap();
    assert_eq!(json_u64(&v, "/font/count"), 1);
    assert_eq!(json_u64(&v, "/font/entries/0/size"), 12);
    assert_eq!(json_u64(&v, "/font/entries/0/glyph_count"), 1);
    assert_eq!(json_u64(&v, "/font/entries/0/glyphs/0/character"), 65);
}

// ── v15_objt ──────────────────────────────────────────────────────────────────

#[test]
fn objt_json_file_size() {
    check_json_file_size(JSON_OBJT, OBJT_FIXTURE, "v15_objt");
}

#[test]
fn objt_parse() {
    let index = ChunkIndex::parse(OBJT_FIXTURE).unwrap();
    let entry = index.find(b"OBJT").unwrap();
    let objt = Objt::parse(
        &OBJT_FIXTURE[entry.data_offset()..entry.data_offset() + entry.size],
        OBJT_FIXTURE,
        BytecodeVersion(15),
    )
    .unwrap();

    assert_eq!(objt.objects.len(), 1);
    let o = &objt.objects[0];
    assert_eq!(o.name.resolve(OBJT_FIXTURE).unwrap(), "obj_player");
    assert_eq!(o.sprite_index, 0);
    assert!(o.visible);
    assert!(!o.solid);
    assert_eq!(o.depth, 0);
    assert!(!o.persistent);
    assert_eq!(o.parent_index, -1);
    assert_eq!(o.mask_index, -1);
    assert!(!o.physics_enabled);
    assert!(!o.physics_sensor);
    assert_eq!(o.physics_vertices.len(), 0);
    assert!(!o.physics_kinematic);
    assert!(o.physics_awake);
    assert_eq!(o.events.len(), 0);

    let v: serde_json::Value = serde_json::from_str(JSON_OBJT).unwrap();
    assert_eq!(json_u64(&v, "/objt/count"), 1);
    assert_eq!(json_u64(&v, "/objt/entries/0/sprite_index"), 0);
    assert_eq!(json_u64(&v, "/objt/entries/0/event_type_count"), 0);
}

// ── v15_room ──────────────────────────────────────────────────────────────────

#[test]
fn room_json_file_size() {
    check_json_file_size(JSON_ROOM, ROOM_FIXTURE, "v15_room");
}

#[test]
fn room_parse() {
    let index = ChunkIndex::parse(ROOM_FIXTURE).unwrap();
    let entry = index.find(b"ROOM").unwrap();
    let room =
        Room::parse(&ROOM_FIXTURE[entry.data_offset()..entry.data_offset() + entry.size], ROOM_FIXTURE)
            .unwrap();

    assert_eq!(room.rooms.len(), 1);
    let r = &room.rooms[0];
    assert_eq!(r.name.resolve(ROOM_FIXTURE).unwrap(), "rm_main");
    assert_eq!(r.caption.resolve(ROOM_FIXTURE).unwrap(), "");
    assert_eq!(r.width, 640);
    assert_eq!(r.height, 480);
    assert_eq!(r.speed, 60);
    assert!(!r.persistent);
    assert_eq!(r.background_color, 0);
    assert!(r.draw_background_color);
    assert_eq!(r.creation_code_id, -1);
    assert_eq!(r.flags, 0);
    assert_eq!(r.objects.len(), 0);
    assert!(!r.physics_world);
    assert!((r.physics_gravity_x - 0.0).abs() < 1e-6);
    assert!((r.physics_gravity_y - 10.0).abs() < 1e-6);

    let v: serde_json::Value = serde_json::from_str(JSON_ROOM).unwrap();
    assert_eq!(json_u64(&v, "/room/count"), 1);
    assert_eq!(json_u64(&v, "/room/entries/0/width"), 640);
    assert_eq!(json_u64(&v, "/room/entries/0/height"), 480);
    assert_eq!(json_u64(&v, "/room/entries/0/speed"), 60);
    assert_eq!(json_u64(&v, "/room/entries/0/object_count"), 0);
}
